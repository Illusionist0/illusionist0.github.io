[{"title":"The Wisdom of Asking Questions","path":"/2023/03/13/ask/","content":"Ask the proper person for the proper question Search before asking Try it yourself before asking Describe the question accurately Give feedback to the person you ask","categories":["Principles"]},{"title":"CPP笔记08","path":"/2020/04/23/cpp8/","content":"第八章 函数探幽C++内联函数 inline编译器使用相应的函数代码替换函数调用，运行速度更快，但代价是需要占用更多内存。 即典型的空间换时间。 应有选择的使用内联函数。 通过的做法是省略原型，将整个定义放在本应提供原型的地方。 注意，有些编译器认为函数过大或注意到函数调用了自己，因此将不会满足程序员内联函数的请求；但是有些编译器则没有实现。 宏和内联的区别 宏不能按值传递，如#define square(x) x*x，若使用square (c++),那么计算结果便是c++*c++ 引用变量&amp;在这里并不是取地址运算符，而有另一个作用，那就是引用声明 1234int a;int &amp;b=a;//yes，等价于int *const pa=a;int &amp;b;b=a;//no，必须在声明引用变量时进行初始化 此时，b就是对a的引用。 引用作为函数参数123void swapr(int &amp;a.int &amp;b);//引用void swapp(int *p ,int *q);//传递值的指针地址void swapv(int a,int b);//仅传递值，无法实现交换a和b 创建临时变量（实参类型正确但非左值 or 实参类型不正确但可以转换，如long转int） 临时变量将导致C++创建匿名变量进而导致参数的值传递给匿名变量，并让参数来引用变量。 这样，就无法实现交换真正的a和b，只会交换临时变量。临时变量在现有标准中仍然只是造成警告，但是请不要忽略相关警告。 此外，C++还新增了一种引用——右值引用。 123double j=15.0;double &amp;&amp;ref=2.0*j+18.5;cout&lt;&lt;ref;//replay: 48.5 引用用于结构 引用非常适合用于结构和类，引用主要是为了这些类型，而非基本的内置类型。 函数中ftype &amp;func(ftype&amp;target)和ftype func(ftype&amp;target)的区别在于后者将会返回target的拷贝，返回类型为引用，也就是意味着返回的是最初传递给func的对象，即未把修改后的对象返回。 为何要返回引用？ 因为传统返回相当于把返回值复制到临时位置，而返回引用将直接返回return的对象。 返回引用注意的问题 不能再函数中创建引用再返回引用, 如 12345const f&amp; clone(f &amp;ft)&#123; f n; n=ft; return n;&#125; 这样会造成返回一个指向临时变量n的引用，但是当函数运行完毕后它将不会存在。 返回一个作为参数传递给函数的引用，作为参数的引用将指向调用函数使用的数据，因此返回的引用也将指向这些数据。 又或者如 123456const f&amp; clone(f &amp;ft)&#123; f *pt; *pt=ft; return *pt;&#125;f &amp; jo=clone(three); pt指向结构，*pt就是该结构，看似会返回该结构，但其实将返回该结构的引用。这样，j会成为新结构的引用。 为何将const用于引用返回类型 因为常规返回类型是右值，但是引用返回类型可以是左值（可以被修改），为了避免这种情况的发生就需要加上const。当然，通常可以省略const，使代码简短，但是特性也会更加模糊。 引用用于类对象 s```和```const &string s```效果一样，但采取引用效率更高，因为函数不需要创建新的string对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- 对象、继承和引用 继承的第一个特征是派生类能够继承基类的方法，即可以使用基类的特性。 继承的另一个特征是，基类引用可以指向派生类对象，而无需进行强制类型转换。这种特征的实际结果是```可以定义接受基类引用作为参数的函数```，调用该函数时可以将基类对象作为参数也可以将派生类对象作为参数。- 何时使用引用参数 使用引用参数的主要原因有两个： 1. 程序员能够修改调用函数中的数据对象； 2. 通过传递引用而不是整个数据对象，可以提高程序的运行速度。 当数据对象较大（如结构和类对象），第二个原因最重要。 对于使用传递的值而不作修改的函数： - 如果数据对象**很小**，如内置数据类型或小型结构，则**按值传递**。 - 如果数据对象是**数组**，则使用**指针**。 - 如果数据对象是**较大的结构**，则使用**const指针或const引用**。 - 如果数据对象是**类对象**，则使用**const引用**。 对于修改调用函数中数据的函数： - 如果数据对象是**内置数据类型**，则使用**指针**。 - 如果数据对象是**数组**，则只能使用**指针**。 - 如果数据对象是**结构**，则使用**指针或引用**。 - 如果数据对象是**类对象**，则使用**引用**。## 默认参数默认参数是指当函数调用中省略了实参时自动使用的一个值，缺省将默认采用初始化值，否则将覆盖。对于带参列表，必须**从右到左**添加默认值。## 函数重载函数多态是C++在C语言基础上新增的功能。默认参数让不同数目的参数调用同一函数，函数多态则能够使用多个同名函数，与函数重载是同一回事。函数重载的关键是函数的参数列表——也称为**函数特征标**，指的是参数类型和/或参数数目。注：返回类型可以不同，但是特征标也必须不同。名称修饰（对原始名称进行表面看来无意义的修饰，将对参数数目和类型进行编码）## 函数模板在C++98添加关键字typename之前，C++使用关键字class创建模板。如果不考虑向后兼容的问题，则声明类型参数时应使用typename。局限在于**有时候可能无法处理某些类型**，比如数组或者指针并不能进行乘法。但是通用化确实是有意义的。- 显式具体化```c++// 非模板版本void _swap(job &amp;,job &amp;);// 模板版本template&lt;typename T&gt;void _swap(T&amp;,T&amp;);// 显式具体化template&lt;&gt; void _swap&lt;job&gt;(job &amp;,job &amp;); 如果有多个原型，编译器在选择原型时，非模板版本优先于显式具体化和模板版本，而显式具体化优先于使用模板生成的版本。 实例化和具体化 1234// 显示实例化template void _swap&lt;job&gt;(job &amp;,job &amp;);// 显式具体化template&lt;&gt; void _swap&lt;job&gt;(job &amp;,job &amp;); 区别在于实例化不需要额外的函数定义，但是具体化则不采用模板来生成函数定义，因此必须有自己的函数定义，同时后面有&lt;&gt;。 重载解析C++ 需要一个定义良好的策略，来决定为函数嗲用使用哪一个函数定义，尤其是有多个参数时，这个过程称为重载解析。 过程： 创建候选函数列表。&#x2F;名称相同 使用候选函数列表创建可行函数列表。&#x2F;参数数目正确，有一个隐式转换序列。 确定是否有最佳的可行函数。&#x2F;如果有则使用，否则报错。 匹配规则： 完全匹配，常规函数优先于模板。 提升转换（char-&gt;int）。 标准转换（int-&gt;char）。 用户定义的转换。 完全匹配可能会有多个匹配的原型，会产生二义性错误。但是有时候，非const会优先匹配非const参数。 非模板函数会优先于模板函数。 C++ 11新增的关键字decltype将会解决T1 x和T2 y相加得到z的类型的问题，如decltype(x+y)z=x+y; double h(int x,float y);可以改写为auto h(int x,float y)-&gt;double","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记07","path":"/2020/04/16/cpp7/","content":"第七章 函数——C++的编程模块函数原型 为什么需要原型1原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型以及参数的类型和数量告诉编译器。 函数原型放在函数头，不需要提供变量名，有类型列表就够了 原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同 原型有什么用？&#96; - 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 检查使用的参数类型是否正确，如果不正确则转换为正确的类型 C++原型与ANSI原型12341. ANSI C中原型是可选的，C++中是必须的2. 括号为空与在括号中使用关键字void是等效的——意味着函数没有参数。3. 在ANSI C中，括号为空意味着不指出参数——这意味这将在后面定义参数列表。 在C++中，不指定参数列表时应使用省略号：void fun(...); 仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。 在编译阶段进行的原型化被称为静态类型检查，可以看出静态类型检查可捕获许多在运行阶段非常难以捕获的错误。 函数参数和按值传递 形参 (parameter) 实参 (argument) 函数中的变量是局部变量，也被称为自动变量，因为它们是在程序执行过程中自动被分配和释放的 数组名与指针对应是好事吗？ 是，将数组地址作为参数可以节省复制整个数组所需的时间和内存。 不要使用方括号表示法来传递数组长度1void fun(int arr[size]);//bad prototype 使用数组区间函数 传递起始指针和初始位置 指定元素区间 STL方法使用“超尾” 指针和const有两种方法如下： 指针指向一个常量对象12int age=10;const int *p=&amp;age; pt指向一个const int,因此不能使用pt来修改这个值。换句话来说，*pt的值为const，不能被修改。 pt的声明不意味着他指向的值实际上就是一个常量，也就是age可以被修改。 将const变量的地址赋给指向const的指针，可行12float g_e=9.80;const float *pe=&amp;g_e;//valid 将const变量的地址赋给常规指针，不可行12const float g_m=1.63;float *pm=&amp;g_m;//invalid 一级间接关系，将非const指针赋给const指针是可以的123int age=10;int *pd=&amp;age;//validconst int *pt=pd;//invalid 二级间接关系，与一级间接关系一样将const和非const混合的指针赋值方式将不再安全。123456const int **pp2;int *p1;const int n=13;pp2=&amp;p1;//不被允许的语法，假设允许*pp2=&amp;n;//valid,both const,but sets p1 to point at n*p1=10;//valid,but changes const n 上述代码中将非const地址&amp;p1赋给了const指针pp2,因此可以使用p1来修改const数据。 因此，仅当只有一层间接关系时，才可以将非const地址或者指针赋给const指针。 如果数据类型本身不是指针，可以将const或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。 尽可能使用const 可以避免由于无意间修改数据而导致的编程错误； 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。 如果条件允许，则应将指针形参声明为指向const的指针。 指针本身声明为常量使用const使得无法修改指针的值：123int sloth=3;const int * ps =&amp;sloth; //常量指针int * const finger= &amp;sloth;//指针常量 函数和二维数组 like int sum(int *ar[4],int n); 函数和C-style字符串 char数组 用引号括起的字符串常量 被设置为字符串的地址的char指针字符串与char数组的最大区别在于有内置的结束字符 函数和结构 结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&amp;。 在C语言和C++中，都使用符号&amp;来标识地址运算符。 采用&amp;能够对原始结构进行操作。 函数和string对象 likestring s[size]; 函数和array对象 likearray&lt;string,4&gt;seasons 递归 注意，C++不允许main()调用自己，但是C语言允许 函数指针 double (*pf)(int);&#x2F;&#x2F;pf是函数指针，即一个指向函数的指针；调用时(*pf)等价于pf double *pf(int);&#x2F;&#x2F;pf是指针函数，即一个函数，返回值为double指针 auto自动类型推导只能用于单值初始化，但不能用于初始化列表 auto存在一个潜在缺点： auto pc=*pa;会导致pc的类型于*pa一致，但使用时如果假定他类型为指针（如&amp;pa）将导致编译错误。","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记06","path":"/2020/04/15/cpp6/","content":"第六章 分支语句和逻辑运算符 if if-else &amp;&amp; || ! 与或非 逻辑表达式 注意短路原则 cctype 比如isspace(),ispunct(),isalpha(),isalnum(),isdigit() a?b:c等于if(a)b else c switch语句 break continue 文件IO写文件 12345678910ofstream outFile;//代替osofstream fout;//代替osoutFile.open(&quot;xxx.txt&quot;);char filename[50];cin&gt;&gt;filename;fout.open(filename);int a=1;outFile&lt;&lt;a;char line[90]=&quot;xx..(90)&quot;;fout&lt;&lt;line&lt;&lt;endl; 读文件 12345678910ifstream inFile;//代替inifstream fin;//代替ininFile.open(&quot;xxx.txt&quot;);char filename[50];cin&gt;&gt;filename;fout.open(filename);int a;inFile&gt;&gt;a;// read a numberchar line[90];fin.getline(line,90);//read a line","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记05","path":"/2020/04/14/cpp5/","content":"第五章 循环和关系表达式for循环123for(a;b;c)&#123; loop;&#125; ++、–（前缀和后缀）++a;&#x2F;&#x2F;先自增再对a进行运算 a++;&#x2F;&#x2F;先对a进行运算再自增 组合赋值a&#x3D;x;&#x2F;&#x2F;即a&#x3D;ax 逗号运算符,一般用于两个表达式或者连续赋值之间 关系表达式 &lt; &#x3D;&#x3D; &lt;&#x3D; &gt;&#x3D; &#x3D;&#x3D;和&#x3D;的区别&#x3D;是赋值，&#x3D;&#x3D;是比较 while123while(condition)&#123; loop;&#125; do while123do&#123; loop;&#125;while(condition);","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记04","path":"/2020/04/13/cpp4/","content":"第四章 复合类型 c++提供了一种数组替代品，模板类vector c++11新增模板类array c++11字符串初始化 1允许将列表初始化用于C风格字符串和string对象 c++11结构初始化 1与数组一样，c++11也支持将列表初始化用于结构，=号可选 c++11增加了作用域内枚举 new和delete 1234567int *p =new int;delete p;//动态数组int *p=new int[10];delete [] p;//不要使用delete释放不是new分配的内存，以及反复delete配对使用，否则可能造成内存泄漏 对指针解除引用 *p or p[0] 分配内存1234567三种方式1.自动存储 存储到栈中2.静态存储 static3.动态存储 管理了一个内存池，自由存储空间或堆","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记03","path":"/2020/04/13/cpp3/","content":"第三章 处理数据大括号初始化{}初始化&#x3D;0 整型选择仅当有大型数组时，才有必要使用short 通用字符\\U \\u C++11 新增的类型char16_tchar32_t const限定符C++11增加autoauto不是为了简单类型推导存在的，是为了复杂类型推导而存在的 课后习题 c++为什么有多种整型？1因为不同整型有着不同的存储范围，为不同规模的数据准备","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记02","path":"/2020/04/12/cpp2/","content":"第二章 开始学习C++ 名称空间using namespace std;是一种偷懒做法，使得全部名称可用，可以换成using std::cout; 头文件名c++新式风格 没有扩展名加上前缀c C++11 新特性原始（raw）字符串可包含回车 C++和C有一项不寻常的特性可以连续使用赋值运算符 123int a,b,c;a=b=c=10;赋值从右向左进行，10首先赋给c，c的值赋给b,b的值赋给a 课后习题 c++程序的模块是什么？12345678函数。 为什么呢？ 由于函数创建Ｃ＋＋程序的模块，对于Ｃ＋＋的ＯＯＰ至关重要。 函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。甚至也可以是一个函数，只要它完成一个功能，它就可以视为一个模块。 而C++的模块一般是指一组函数的集合，来实现某一领域特定的功能。表现形式可以是封装在dll中的一组接口，也可以是在某个namespace下的一组API等等，主要是一个逻辑概念。 这样看来，模块是指完成一个功能的函数集合，所以函数必不可少。 还有一种说法：模块是一个比较模糊的概念。在BS的《The C++ Programming Language Special 3rd Edition》中，把一个名字空间视为一个模块。 所以说无需太对模块的概念过于关注，不同的地方往往需要结合上下文进行理解，不用过于在意其定义。","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记01","path":"/2020/04/11/cpp1/","content":"第一章 预备知识 c（c++）程序的生成过程： 编写源代码-&gt;编译-&gt;链接 。 对应的各个阶段处理的文件的扩展名为： .c或.cpp-&gt;.obj-&gt;.exe。 编译 何为编译？12345首先我们要明白两个概念，源程序和目标程序。源程序：是指用源语言写的，有待翻译的程序，如我们自己写的一段c++代码，这段代码只有我们自己能看懂，计算机是不懂，计算机只能理解二进制。目标程序：源程序通过翻译程序加工以后生成的机器语言程序。这是计算机可以理解的语言。把源程序转化为目标程序的操作就叫做编译。 链接 何为链接？12345C语言代码经过编译以后，会变成了二进制形式的目标文件（Object File）--- 对于 Visual C++，目标文件的后缀是.obj，对于 GCC，目标文件的后缀是.o。但此时的代码还不能运行起来。 因为它还需要和系统提供的组件（比如标准库）结合起来，这些组件都是程序运行所必须的。 例如我们要在屏幕中输出字符，这必须调用系统提供的库才能够实现。这就是链接，经过链接才会生成 可执行程序 （如 win 平台上的exe） 链接中如果出现重复的同名obj解决方案有： static，使得同名函数对其他obj不可见 inline，即非调用，但是对内存空间不是很友好 只在一个cpp文件中给出具体函数体的定义 总结 1234不管我们编写的代码有多么简单，都必须经过「编译 --&gt; 链接」的过程才能生成可执行文件：编译就是将我们编写的源代码“翻译”成计算机可以识别的二进制格式，它们以目标文件的形式存在；链接就是一个“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。 何为编译程序？ 123456789计算机并不能直接地接受和执行用高级语言编写的源程序，源程序在输入计算机时，通过&quot;编译程序&quot;翻译成机器语言形式的目标程序。翻译程序有两种：一种是编译程序，它将高级语言源程序一次性全部翻译成目标程序，每次执行程序时，只要执行目标程序。如 C（c++）程序的生成要经过： 编写源代码-&gt;编译-&gt;链接；另一种是解释程序，它的执行过程是翻译一句执行一句，并且不会生成目标程序。如JavaScript、Python等。编译程序与解释程序最大的区别之一在于前者生成目标代码，而后者不生成；此外，前者产生的目标代码的执行速度比解释程序的执行速度要快。 除此以外，汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译成机器语言程序，它是为低级语言服务的。解释程序和编译程序是为高级语言服务的。 java是一种半编译、半解释执行的语言？123对于C和C++，它们经过一次编译之后，可以由操作系统直接执行，所以它们是编译型语言。而Java不一样，它首先由编译器编译成.class文件，然后在通过JVM从class文件中读一行解释执行一行，所以它是解释型的语言。也正是由于java对于多种不同的操作系统有不同的JVM，所以实现了真正意义上的跨平台。","tags":["C++","CPP"],"categories":["C++"]},{"title":"ME","path":"/about/index.html","content":"I AM XZN"},{"title":"区块链实战开发","path":"/wiki/blockchain/index.html","content":"B站"}]