[{"title":"The Wisdom of Asking Questions","path":"/2023/03/13/ask/","content":"Ask the proper person for the proper question Search before asking Try it yourself before asking Describe the question accurately Give feedback to the person you ask","categories":["Principles"]},{"title":"CPP笔记08","path":"/2020/04/19/cpp8/","content":"第八章 函数探幽C++内联函数 inline编译器使用相应的函数代码替换函数调用，运行速度更快，但代价是需要占用更多内存。 即典型的空间换时间。 应有选择的使用内联函数。 通过的做法是省略原型，将整个定义放在本应提供原型的地方。 注意，有些编译器认为函数过大或注意到函数调用了自己，因此将不会满足程序员内联函数的请求；但是有些编译器则没有实现。 宏和内联的区别 宏不能按值传递，如#define square(x) x*x，若使用square (c++),那么计算结果便是c++*c++ 引用变量&amp;在这里并不是取地址运算符，而有另一个作用，那就是引用声明 1234int a;int &amp;b=a;//yes，等价于int *const pa=a;int &amp;b;b=a;//no，必须在声明引用变量时进行初始化 此时，b就是对a的引用。 引用作为函数参数123void swapr(int &amp;a.int &amp;b);//引用void swapp(int *p ,int *q);//传递值的指针地址void swapv(int a,int b);//仅传递值，无法实现交换a和b 引用用于结构","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记07","path":"/2020/04/16/cpp7/","content":"第七章 函数——C++的编程模块函数原型 为什么需要原型1原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型以及参数的类型和数量告诉编译器。 函数原型放在函数头，不需要提供变量名，有类型列表就够了 原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同 原型有什么用？&#96; - 编译器正确处理函数返回值 编译器检查使用的参数数目是否正确 检查使用的参数类型是否正确，如果不正确则转换为正确的类型 C++原型与ANSI原型12341. ANSI C中原型是可选的，C++中是必须的2. 括号为空与在括号中使用关键字void是等效的——意味着函数没有参数。3. 在ANSI C中，括号为空意味着不指出参数——这意味这将在后面定义参数列表。 在C++中，不指定参数列表时应使用省略号：void fun(...); 仅当有意义时，原型化才会导致类型转换。例如，原型不会将整数转换为结构或指针。 在编译阶段进行的原型化被称为静态类型检查，可以看出静态类型检查可捕获许多在运行阶段非常难以捕获的错误。 函数参数和按值传递 形参 (parameter) 实参 (argument) 函数中的变量是局部变量，也被称为自动变量，因为它们是在程序执行过程中自动被分配和释放的 数组名与指针对应是好事吗？ 是，将数组地址作为参数可以节省复制整个数组所需的时间和内存。 不要使用方括号表示法来传递数组长度1void fun(int arr[size]);//bad prototype 使用数组区间函数 传递起始指针和初始位置 指定元素区间 STL方法使用“超尾” 指针和const有两种方法如下： 指针指向一个常量对象12int age=10;const int *p=&amp;age; pt指向一个const int,因此不能使用pt来修改这个值。换句话来说，*pt的值为const，不能被修改。 pt的声明不意味着他指向的值实际上就是一个常量，也就是age可以被修改。 将const变量的地址赋给指向const的指针，可行12float g_e=9.80;const float *pe=&amp;g_e;//valid 将const变量的地址赋给常规指针，不可行12const float g_m=1.63;float *pm=&amp;g_m;//invalid 一级间接关系，将非const指针赋给const指针是可以的123int age=10;int *pd=&amp;age;//validconst int *pt=pd;//invalid 二级间接关系，与一级间接关系一样将const和非const混合的指针赋值方式将不再安全。123456const int **pp2;int *p1;const int n=13;pp2=&amp;p1;//不被允许的语法，假设允许*pp2=&amp;n;//valid,both const,but sets p1 to point at n*p1=10;//valid,but changes const n 上述代码中将非const地址&amp;p1赋给了const指针pp2,因此可以使用p1来修改const数据。 因此，仅当只有一层间接关系时，才可以将非const地址或者指针赋给const指针。 如果数据类型本身不是指针，可以将const或非const数据的地址赋给指向const的指针，但只能将非const数据的地址赋给非const指针。 尽可能使用const 可以避免由于无意间修改数据而导致的编程错误； 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。 如果条件允许，则应将指针形参声明为指向const的指针。 指针本身声明为常量使用const使得无法修改指针的值：123int sloth=3;const int * ps =&amp;sloth; //常量指针int * const finger= &amp;sloth;//指针常量 函数和二维数组 like int sum(int *ar[4],int n); 函数和C-style字符串 char数组 用引号括起的字符串常量 被设置为字符串的地址的char指针字符串与char数组的最大区别在于有内置的结束字符 函数和结构 结构名只是结构的名称，要获得结构的地址，必须使用地址运算符&amp;。 在C语言和C++中，都使用符号&amp;来标识地址运算符。 采用&amp;能够对原始结构进行操作。 函数和string对象 likestring s[size]; 函数和array对象 likearray&lt;string,4&gt;seasons 递归 注意，C++不允许main()调用自己，但是C语言允许 函数指针 double (*pf)(int);&#x2F;&#x2F;pf是函数指针，即一个指向函数的指针；调用时(*pf)等价于pf double *pf(int);&#x2F;&#x2F;pf是指针函数，即一个函数，返回值为double指针 auto自动类型推导只能用于单值初始化，但不能用于初始化列表 auto存在一个潜在缺点： auto pc=*pa;会导致pc的类型于*pa一致，但使用时如果假定他类型为指针（如&amp;pa）将导致编译错误。","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记06","path":"/2020/04/15/cpp6/","content":"第六章 分支语句和逻辑运算符 if if-else &amp;&amp; || ! 与或非 逻辑表达式 注意短路原则 cctype 比如isspace(),ispunct(),isalpha(),isalnum(),isdigit() a?b:c等于if(a)b else c switch语句 break continue 文件IO写文件 12345678910ofstream outFile;//代替osofstream fout;//代替osoutFile.open(&quot;xxx.txt&quot;);char filename[50];cin&gt;&gt;filename;fout.open(filename);int a=1;outFile&lt;&lt;a;char line[90]=&quot;xx..(90)&quot;;fout&lt;&lt;line&lt;&lt;endl; 读文件 12345678910ifstream inFile;//代替inifstream fin;//代替ininFile.open(&quot;xxx.txt&quot;);char filename[50];cin&gt;&gt;filename;fout.open(filename);int a;inFile&gt;&gt;a;// read a numberchar line[90];fin.getline(line,90);//read a line","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记05","path":"/2020/04/14/cpp5/","content":"第五章 循环和关系表达式for循环123for(a;b;c)&#123; loop;&#125; ++、–（前缀和后缀）++a;&#x2F;&#x2F;先自增再对a进行运算 a++;&#x2F;&#x2F;先对a进行运算再自增 组合赋值a&#x3D;x;&#x2F;&#x2F;即a&#x3D;ax 逗号运算符,一般用于两个表达式或者连续赋值之间 关系表达式 &lt; &#x3D;&#x3D; &lt;&#x3D; &gt;&#x3D; &#x3D;&#x3D;和&#x3D;的区别&#x3D;是赋值，&#x3D;&#x3D;是比较 while123while(condition)&#123; loop;&#125; do while123do&#123; loop;&#125;while(condition);","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记04","path":"/2020/04/13/cpp4/","content":"第四章 复合类型 c++提供了一种数组替代品，模板类vector c++11新增模板类array c++11字符串初始化 1允许将列表初始化用于C风格字符串和string对象 c++11结构初始化 1与数组一样，c++11也支持将列表初始化用于结构，=号可选 c++11增加了作用域内枚举 new和delete 1234567int *p =new int;delete p;//动态数组int *p=new int[10];delete [] p;//不要使用delete释放不是new分配的内存，以及反复delete配对使用，否则可能造成内存泄漏 对指针解除引用 *p or p[0] 分配内存1234567三种方式1.自动存储 存储到栈中2.静态存储 static3.动态存储 管理了一个内存池，自由存储空间或堆","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记03","path":"/2020/04/13/cpp3/","content":"第三章 处理数据大括号初始化{}初始化&#x3D;0 整型选择仅当有大型数组时，才有必要使用short 通用字符\\U \\u C++11 新增的类型char16_tchar32_t const限定符C++11增加autoauto不是为了简单类型推导存在的，是为了复杂类型推导而存在的 课后习题 c++为什么有多种整型？1因为不同整型有着不同的存储范围，为不同规模的数据准备","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记02","path":"/2020/04/12/cpp2/","content":"第二章 开始学习C++ 名称空间using namespace std;是一种偷懒做法，使得全部名称可用，可以换成using std::cout; 头文件名c++新式风格 没有扩展名加上前缀c C++11 新特性原始（raw）字符串可包含回车 C++和C有一项不寻常的特性可以连续使用赋值运算符 123int a,b,c;a=b=c=10;赋值从右向左进行，10首先赋给c，c的值赋给b,b的值赋给a 课后习题 c++程序的模块是什么？12345678函数。 为什么呢？ 由于函数创建Ｃ＋＋程序的模块，对于Ｃ＋＋的ＯＯＰ至关重要。 函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。甚至也可以是一个函数，只要它完成一个功能，它就可以视为一个模块。 而C++的模块一般是指一组函数的集合，来实现某一领域特定的功能。表现形式可以是封装在dll中的一组接口，也可以是在某个namespace下的一组API等等，主要是一个逻辑概念。 这样看来，模块是指完成一个功能的函数集合，所以函数必不可少。 还有一种说法：模块是一个比较模糊的概念。在BS的《The C++ Programming Language Special 3rd Edition》中，把一个名字空间视为一个模块。 所以说无需太对模块的概念过于关注，不同的地方往往需要结合上下文进行理解，不用过于在意其定义。","tags":["C++","CPP"],"categories":["C++"]},{"title":"CPP笔记01","path":"/2020/04/11/cpp1/","content":"第一章 预备知识 c（c++）程序的生成过程： 编写源代码-&gt;编译-&gt;链接 。 对应的各个阶段处理的文件的扩展名为： .c或.cpp-&gt;.obj-&gt;.exe。 编译 何为编译？12345首先我们要明白两个概念，源程序和目标程序。源程序：是指用源语言写的，有待翻译的程序，如我们自己写的一段c++代码，这段代码只有我们自己能看懂，计算机是不懂，计算机只能理解二进制。目标程序：源程序通过翻译程序加工以后生成的机器语言程序。这是计算机可以理解的语言。把源程序转化为目标程序的操作就叫做编译。 链接 何为链接？12345C语言代码经过编译以后，会变成了二进制形式的目标文件（Object File）--- 对于 Visual C++，目标文件的后缀是.obj，对于 GCC，目标文件的后缀是.o。但此时的代码还不能运行起来。 因为它还需要和系统提供的组件（比如标准库）结合起来，这些组件都是程序运行所必须的。 例如我们要在屏幕中输出字符，这必须调用系统提供的库才能够实现。这就是链接，经过链接才会生成 可执行程序 （如 win 平台上的exe） 链接中如果出现重复的同名obj解决方案有： static，使得同名函数对其他obj不可见 inline，即非调用，但是对内存空间不是很友好 只在一个cpp文件中给出具体函数体的定义 总结 1234不管我们编写的代码有多么简单，都必须经过「编译 --&gt; 链接」的过程才能生成可执行文件：编译就是将我们编写的源代码“翻译”成计算机可以识别的二进制格式，它们以目标文件的形式存在；链接就是一个“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。 何为编译程序？ 123456789计算机并不能直接地接受和执行用高级语言编写的源程序，源程序在输入计算机时，通过&quot;编译程序&quot;翻译成机器语言形式的目标程序。翻译程序有两种：一种是编译程序，它将高级语言源程序一次性全部翻译成目标程序，每次执行程序时，只要执行目标程序。如 C（c++）程序的生成要经过： 编写源代码-&gt;编译-&gt;链接；另一种是解释程序，它的执行过程是翻译一句执行一句，并且不会生成目标程序。如JavaScript、Python等。编译程序与解释程序最大的区别之一在于前者生成目标代码，而后者不生成；此外，前者产生的目标代码的执行速度比解释程序的执行速度要快。 除此以外，汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译成机器语言程序，它是为低级语言服务的。解释程序和编译程序是为高级语言服务的。 java是一种半编译、半解释执行的语言？123对于C和C++，它们经过一次编译之后，可以由操作系统直接执行，所以它们是编译型语言。而Java不一样，它首先由编译器编译成.class文件，然后在通过JVM从class文件中读一行解释执行一行，所以它是解释型的语言。也正是由于java对于多种不同的操作系统有不同的JVM，所以实现了真正意义上的跨平台。","tags":["C++","CPP"],"categories":["C++"]},{"title":"ME","path":"/about/index.html","content":"I AM XZN"},{"title":"区块链实战开发","path":"/wiki/blockchain/index.html","content":"B站"}]